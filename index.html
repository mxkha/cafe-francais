<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Café Français — Learn French (Canvas)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <style>
    html,body { margin:0; height:100%; background:#0e1428; }
    canvas { display:block; width:100vw; height:100vh; outline:none; }
    /* UI renders ONLY on canvas; this CSS is just to size the canvas */
  </style>
</head>
<body>
<canvas id="app"></canvas>
<script>
(() => {
  // ===========================
  //   CAFÉ FRANÇAIS (Canvas)
  // ===========================
  // Theme vibes: cozy Parisian café at night; warm gold highlights; playful confetti.
  // Activities: Flashcards, Quiz, "Cheese Chase" (snake-style with a mouse).
  // Voice: Web Speech API; French word (fr-FR), then English gloss (en-GB).
  // Progress: localStorage with per-day stats + streak; simple XP notion and 14-day chart.
  // Everything you click or see is drawn to canvas. No DOM buttons. No images.

  // ---------- Canvas & scale ----------
  const canvas = document.getElementById('app');
  const ctx = canvas.getContext('2d');
  let DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  function resize() {
    DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    canvas.width  = Math.floor(window.innerWidth * DPR);
    canvas.height = Math.floor(window.innerHeight * DPR);
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // ---------- Colors & fonts ----------
  const theme = {
    bg: '#0e1428',
    bg2:'#111a33',
    cream: '#f5e6cc',
    gold: '#ffd166',
    coral: '#ff6f61',
    teal: '#06d6a0',
    lilac: '#cdb4db',
    line: '#2b3557',
    text: '#f8f9fb',
    shadow: 'rgba(0,0,0,0.35)',
  };
  const fontMain = 'system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  function font(size, weight=600) {
    return `${weight} ${size}px ${fontMain}`;
  }

  // ---------- Utility ----------
  function lerp(a,b,t){return a+(b-a)*t}
  function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
  function rnd(a,b){return Math.random()*(b-a)+a}
  function todayKey(d=new Date()){
    return new Date(d.getTime() - d.getTimezoneOffset()*60000).toISOString().slice(0,10)
  }

  // ---------- Words (expandable) ----------
  // A compact starter pack across categories; add more freely.
  const WORDS = [
    // greetings & basics
    {fr:'bonjour', en:'hello', cat:'greeting'},
    {fr:'salut', en:'hi', cat:'greeting'},
    {fr:'bonsoir', en:'good evening', cat:'greeting'},
    {fr:'merci', en:'thank you', cat:'polite'},
    {fr:'s’il vous plaît', en:'please (formal)', cat:'polite'},
    {fr:'s’il te plaît', en:'please (informal)', cat:'polite'},
    {fr:'de rien', en:'you’re welcome', cat:'polite'},
    {fr:'pardon', en:'sorry / excuse me', cat:'polite'},
    {fr:'oui', en:'yes', cat:'basic'},
    {fr:'non', en:'no', cat:'basic'},
    {fr:'peut-être', en:'maybe', cat:'basic'},
    // food
    {fr:'fromage', en:'cheese', cat:'food'},
    {fr:'pain', en:'bread', cat:'food'},
    {fr:'eau', en:'water', cat:'food'},
    {fr:'café', en:'coffee', cat:'food'},
    {fr:'thé', en:'tea', cat:'food'},
    {fr:'pomme', en:'apple', cat:'food'},
    {fr:'croissant', en:'croissant', cat:'food'},
    {fr:'chocolat', en:'chocolate', cat:'food'},
    {fr:'sucre', en:'sugar', cat:'food'},
    // travel
    {fr:'gare', en:'train station', cat:'travel'},
    {fr:'aéroport', en:'airport', cat:'travel'},
    {fr:'hôtel', en:'hotel', cat:'travel'},
    {fr:'carte', en:'map / menu', cat:'travel'},
    {fr:'billet', en:'ticket', cat:'travel'},
    {fr:'bagage', en:'luggage', cat:'travel'},
    {fr:'toilettes', en:'restroom', cat:'travel'},
    // verbs
    {fr:'aller', en:'to go', cat:'verb'},
    {fr:'avoir', en:'to have', cat:'verb'},
    {fr:'être', en:'to be', cat:'verb'},
    {fr:'faire', en:'to do / make', cat:'verb'},
    {fr:'vouloir', en:'to want', cat:'verb'},
    {fr:'pouvoir', en:'to be able to', cat:'verb'},
    {fr:'manger', en:'to eat', cat:'verb'},
    {fr:'boire', en:'to drink', cat:'verb'},
    {fr:'parler', en:'to speak', cat:'verb'},
    {fr:'apprendre', en:'to learn', cat:'verb'},
    // adjectives
    {fr:'grand', en:'big / tall', cat:'adj'},
    {fr:'petit', en:'small', cat:'adj'},
    {fr:'chaud', en:'hot', cat:'adj'},
    {fr:'froid', en:'cold', cat:'adj'},
    {fr:'bon', en:'good', cat:'adj'},
    {fr:'mauvais', en:'bad', cat:'adj'},
    {fr:'beau', en:'beautiful (m.)', cat:'adj'},
    {fr:'belle', en:'beautiful (f.)', cat:'adj'},
    // life & places
    {fr:'maison', en:'house', cat:'place'},
    {fr:'école', en:'school', cat:'place'},
    {fr:'travail', en:'work', cat:'place'},
    {fr:'rue', en:'street', cat:'place'},
    {fr:'ville', en:'city', cat:'place'},
    {fr:'pays', en:'country', cat:'place'},
    // numbers
    {fr:'un', en:'one', cat:'num'},
    {fr:'deux', en:'two', cat:'num'},
    {fr:'trois', en:'three', cat:'num'},
    {fr:'quatre', en:'four', cat:'num'},
    {fr:'cinq', en:'five', cat:'num'},
    {fr:'six', en:'six', cat:'num'},
    {fr:'sept', en:'seven', cat:'num'},
    {fr:'huit', en:'eight', cat:'num'},
    {fr:'neuf', en:'nine', cat:'num'},
    {fr:'dix', en:'ten', cat:'num'},
  ];
  function shuffle(a){ for(let i=a.length-1;i>0;i--){const j=(Math.random()* (i+1))|0; [a[i],a[j]]=[a[j],a[i]]} return a }

  // ---------- Speech (TTS) ----------
  let voices = [];
  let canSpeak = false;
  let muted = false;
  const voicePrefs = { fr: null, en: null, rate: 0.95, pitch: 1.0, volume: 1.0 };
  function refreshVoices(){
    voices = window.speechSynthesis ? window.speechSynthesis.getVoices() : [];
    // pick fr and en voices
    const frs = voices.filter(v=>/fr/i.test(v.lang));
    const ens = voices.filter(v=>/en/i.test(v.lang)&&/GB|US|EN/i.test(v.lang));
    voicePrefs.fr = frs[0] || voices.find(v=>v.lang==='fr-FR') || null;
    voicePrefs.en = ens[0] || voices.find(v=>v.lang==='en-GB') || voices.find(v=>v.lang==='en-US') || null;
  }
  if ('speechSynthesis' in window) {
    window.speechSynthesis.onvoiceschanged = refreshVoices;
    refreshVoices();
  }
  function speakOnce(text, lang, delay=0){
    if (muted || !window.speechSynthesis || !canSpeak) return;
    const u = new SpeechSynthesisUtterance(text);
    u.lang = lang;
    u.rate = voicePrefs.rate;
    u.pitch = voicePrefs.pitch;
    u.volume = voicePrefs.volume;
    if (lang.startsWith('fr') && voicePrefs.fr) u.voice = voicePrefs.fr;
    if (lang.startsWith('en') && voicePrefs.en) u.voice = voicePrefs.en;
    setTimeout(()=>speechSynthesis.speak(u), delay);
  }
  function speakWord(fr,en) {
    if (!window.speechSynthesis || muted) return;
    try { speechSynthesis.cancel(); } catch(e){}
    speakOnce(fr, 'fr-FR', 0);
    speakOnce(en, 'en-GB', 500);
  }

  // ---------- Progress (localStorage) ----------
  const LS_KEY = 'cafe_francais_progress_v1';
  function loadProgress(){
    try { return JSON.parse(localStorage.getItem(LS_KEY)) || { days:{}, words:{} } }
    catch(e){ return {days:{},words:{}} }
  }
  function saveProgress(){ localStorage.setItem(LS_KEY, JSON.stringify(progress)) }
  let progress = loadProgress();
  function ensureToday(){
    const k = todayKey();
    if (!progress.days[k]) progress.days[k] = {
      minutes:0, flashcards:0, quizTotal:0, quizCorrect:0,
      cheese:0, wordsHeard:0, activities:{flash:false,quiz:false,game:false}
    };
    return progress.days[k];
  }
  let sessionStart = Date.now();
  function bump(field, amount=1){
    const t = ensureToday();
    t[field] = (t[field]||0)+amount; saveProgress();
  }
  function setPlayed(activity) {
    const t = ensureToday();
    t.activities[activity] = true; saveProgress();
  }
  function onWordHeard(fr){
    progress.words[fr] = (progress.words[fr]||0)+1;
    ensureToday().wordsHeard++; saveProgress();
  }
  function updateMinutes(){ // call on scene change & on exit
    const mins = (Date.now() - sessionStart)/(1000*60);
    ensureToday().minutes += mins;
    sessionStart = Date.now(); saveProgress();
  }
  function daysArray(n=14){
    const arr=[];
    for(let i=n-1;i>=0;i--){
      const d=new Date(); d.setDate(d.getDate()-i);
      const k=todayKey(d);
      arr.push({k, ...(progress.days[k]||{
        minutes:0, flashcards:0, quizTotal:0, quizCorrect:0,
        cheese:0, wordsHeard:0, activities:{flash:false,quiz:false,game:false}
      })});
    }
    return arr;
  }
  function computeStreak(){
    let s=0; let i=0;
    while(true){
      const d=new Date(); d.setDate(d.getDate()-i);
      const k=todayKey(d);
      const day = progress.days[k];
      if (day && (day.flashcards>0 || day.quizTotal>0 || day.cheese>0 || day.wordsHeard>0)) { s++; i++; }
      else break;
    }
    return s;
  }
  function xpForDay(day){
    // a light XP metric
    return Math.round(day.wordsHeard + day.flashcards*0.5 + day.cheese*1 + day.quizCorrect*2);
  }

  // ---------- Input ----------
  let mouse = {x:0,y:0,down:false};
  canvas.addEventListener('pointerdown', e=>{
    canSpeak = true; // first user gesture unlocks TTS
    const r = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - r.left) * DPR; mouse.y = (e.clientY - r.top) * DPR;
    mouse.down = true;
    if (currentScene && currentScene.pointerDown) currentScene.pointerDown(mouse.x, mouse.y);
  });
  canvas.addEventListener('pointermove', e=>{
    const r = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - r.left) * DPR; mouse.y = (e.clientY - r.top) * DPR;
    if (currentScene && currentScene.pointerMove) currentScene.pointerMove(mouse.x, mouse.y);
  });
  canvas.addEventListener('pointerup', e=>{
    mouse.down = false;
    if (currentScene && currentScene.pointerUp) currentScene.pointerUp(mouse.x, mouse.y);
  });
  const keys = {};
  window.addEventListener('keydown', e=>{
    keys[e.key] = true;
    if (currentScene && currentScene.keyDown) currentScene.keyDown(e.key);
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
  }, {passive:false});
  window.addEventListener('keyup', e=>{ keys[e.key] = false; if (currentScene && currentScene.keyUp) currentScene.keyUp(e.key); });

  // ---------- UI helpers ----------
  function drawRoundedRect(x,y,w,h,r=12){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }
  function drawShadowBox(x,y,w,h,fill,shadow=true){
    if (shadow){ ctx.save(); ctx.shadowColor=theme.shadow; ctx.shadowBlur=24; ctx.shadowOffsetY=8; }
    ctx.fillStyle = fill; drawRoundedRect(x,y,w,h,18); ctx.fill();
    if (shadow) ctx.restore();
  }
  function drawButton(btn){
    const {x,y,w,h,label,accent=false} = btn;
    const over = hit(btn, hoverX, hoverY);
    const c = accent ? theme.coral : theme.gold;
    drawShadowBox(x,y,w,h, over ? c : theme.cream, true);
    ctx.fillStyle = over ? theme.bg : theme.bg;
    ctx.font = font(Math.floor(h*0.45), 800);
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(label, x+w/2, y+h/2+1);
  }
  function hit(btn, px, py){ return px>=btn.x && px<=btn.x+btn.w && py>=btn.y && py<=btn.y+btn.h }
  let hoverX=-999, hoverY=-999;
  canvas.addEventListener('pointermove', e=>{ hoverX=mouse.x; hoverY=mouse.y; });

  // ---------- Background sparkle ----------
  const sparkles = Array.from({length:48}, ()=>({
    x: rnd(0,canvas.width), y: rnd(0,canvas.height),
    r: rnd(1,3), s: rnd(0.2,0.8), t:rnd(0,Math.PI*2)
  }));
  function drawBackground(){
    // gradient night sky
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0, theme.bg);
    g.addColorStop(1, theme.bg2);
    ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);

    // dim café awning stripes
    const stripeH = Math.floor(64*DPR);
    ctx.globalAlpha = 0.06;
    ctx.fillStyle = theme.line;
    for (let y=0;y<canvas.height;y+=stripeH) ctx.fillRect(0,y,canvas.width,Math.floor(stripeH*0.4));
    ctx.globalAlpha = 1;

    // twinkly sparkles
    sparkles.forEach(p=>{
      p.t += 0.02*p.s;
      const a = 0.2 + 0.2*Math.sin(p.t);
      ctx.globalAlpha = a;
      ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fillStyle = theme.gold; ctx.fill();
      ctx.globalAlpha = 1;
      p.y += 0.1 + 0.3*p.s; if (p.y > canvas.height+10) { p.y = -10; p.x = rnd(0,canvas.width); }
    });

    // silhouette: a hint of Eiffel tower
    ctx.save();
    ctx.globalAlpha = 0.08;
    ctx.fillStyle = '#000';
    const baseY = canvas.height - 80*DPR;
    const baseX = canvas.width*0.82;
    ctx.beginPath();
    ctx.moveTo(baseX-70*DPR, baseY);
    ctx.lineTo(baseX+70*DPR, baseY);
    ctx.lineTo(baseX+10*DPR, baseY-220*DPR);
    ctx.lineTo(baseX-10*DPR, baseY-220*DPR);
    ctx.closePath(); ctx.fill();
    ctx.globalAlpha = 1; ctx.restore();
  }

  // ---------- Scene management ----------
  let currentScene = null;
  function go(scene){
    updateMinutes();
    currentScene = scene; setPlayed(scene.id||'menu');
    if (scene.onEnter) scene.onEnter();
  }

  // ---------- Home Scene ----------
  const Home = {
    id:'menu',
    buttons:[],
    onEnter(){
      this.layout();
    },
    layout(){
      const w = canvas.width, h = canvas.height;
      const cardW = Math.min(520*DPR, w*0.8);
      const cardH = Math.min(520*DPR, h*0.72);
      const x = (w-cardW)/2, y = (h-cardH)/2;
      this.card = {x,y,w:cardW,h:cardH};
      const pad = 22*DPR, bw = cardW - pad*2, bh = 64*DPR;
      const by = y + 140*DPR;
      this.buttons = [
        {x:x+pad,y:by, w:bw, h:bh, label:'Flashcards', on:()=>go(Flashcards)},
        {x:x+pad,y:by+bh+12*DPR, w:bw, h:bh, label:'Quiz', on:()=>go(Quiz)},
        {x:x+pad,y:by+(bh+12*DPR)*2, w:bw, h:bh, label:'Cheese Chase 🧀', on:()=>go(CheeseChase), accent:true},
        {x:x+pad,y:by+(bh+12*DPR)*3, w:bw, h:bh, label:'Progress', on:()=>go(Progress)},
        {x:x+pad,y:by+(bh+12*DPR)*4, w:bw, h:bh, label: muted?'Unmute':'Mute', on:()=>{muted=!muted}},
      ];
    },
    pointerDown(px,py){ for(const b of this.buttons){ if (hit(b,px,py)) return b.on()} },
    keyDown(k){
      if (k==='1') go(Flashcards);
      if (k==='2') go(Quiz);
      if (k==='3') go(CheeseChase);
      if (k==='4') go(Progress);
    },
    draw(){
      drawBackground();
      // Title Card
      const {x,y,w,h} = this.card;
      drawShadowBox(x,y,w,h, theme.cream, true);
      ctx.fillStyle = theme.bg; ctx.textAlign='center'; ctx.textBaseline='top';
      ctx.font = font(Math.floor(42*DPR), 900);
      ctx.fillText('Café Français', x+w/2, y+28*DPR);
      ctx.font = font(Math.floor(20*DPR), 700);
      ctx.fillStyle = '#28324a';
      ctx.fillText('learn French, playfully — tout en canvas', x+w/2, y+78*DPR);

      // Quick stats
      const streak = computeStreak();
      const t = ensureToday();
      ctx.font = font(Math.floor(18*DPR), 700);
      ctx.fillStyle = theme.bg2;
      ctx.fillText(`streak: ${streak} day${streak===1?'':'s'} • words today: ${t.wordsHeard} • cheese: ${t.cheese}`, x+w/2, y+110*DPR);

      // Buttons
      for (const b of this.buttons) drawButton(b);

      // Footer hint
      ctx.font = font(Math.floor(14*DPR), 700);
      ctx.fillStyle = '#334';
      ctx.textAlign='center';
      ctx.fillText('arrow keys for game • space repeats audio • esc returns home', x+w/2, y+h-22*DPR);
    }
  };

  // ---------- Flashcards Scene ----------
  const Flashcards = {
    id:'flash',
    idx:0,
    showBack:false,
    order: shuffle([...WORDS]),
    onEnter(){ this.showBack=false; setPlayed('flash'); },
    next(){ this.idx = (this.idx+1)%this.order.length; this.showBack=false; bump('flashcards',1); },
    prev(){ this.idx = (this.idx-1+this.order.length)%this.order.length; this.showBack=false; bump('flashcards',1); },
    speak(){ const w=this.order[this.idx]; speakWord(w.fr,w.en); onWordHeard(w.fr); },
    pointerDown(px,py){
      if (hit(this.btnNext,px,py)) return this.next();
      if (hit(this.btnPrev,px,py)) return this.prev();
      if (hit(this.btnSpeak,px,py)) return this.speak();
      if (hit(this.btnShuffle,px,py)) { this.order = shuffle([...WORDS]); this.idx=0; this.showBack=false; }
      if (hit(this.btnHome,px,py)) return go(Home);
      if (hit(this.card,px,py)) this.showBack=!this.showBack;
    },
    keyDown(k){ if (k==='ArrowRight') this.next(); if (k==='ArrowLeft') this.prev(); if (k===' ') this.speak(); if (k==='Escape') go(Home); },
    draw(){
      drawBackground();
      const w=canvas.width,h=canvas.height;
      const cardW = Math.min(560*DPR, w*0.9), cardH = Math.min(380*DPR, h*0.6);
      const x = (w-cardW)/2, y = (h-cardH)/2;
      this.card = {x,y,w:cardW,h:cardH};

      // Card
      drawShadowBox(x,y,cardW,cardH, theme.cream, true);
      const word = this.order[this.idx];
      ctx.textAlign='center';
      ctx.fillStyle = theme.bg;
      if (!this.showBack){
        ctx.font = font(Math.floor(34*DPR), 900);
        ctx.fillText(word.fr, x+cardW/2, y+cardH/2 - 10*DPR);
        ctx.font = font(Math.floor(16*DPR), 700);
        ctx.fillStyle = '#5a607d';
        ctx.fillText(`tap to flip • ${word.cat}`, x+cardW/2, y+cardH/2 + 26*DPR);
      } else {
        ctx.font = font(Math.floor(30*DPR), 900);
        ctx.fillText(word.en, x+cardW/2, y+cardH/2 - 10*DPR);
        ctx.font = font(Math.floor(16*DPR), 700);
        ctx.fillStyle = '#5a607d';
        ctx.fillText(`tap to flip • ${word.cat}`, x+cardW/2, y+cardH/2 + 26*DPR);
      }

      // Buttons
      const bw = 150*DPR, bh=56*DPR, pad=14*DPR;
      this.btnPrev   = {x:x, y:y+cardH+pad, w:bw, h:bh, label:'Prev', on:()=>this.prev()};
      this.btnNext   = {x:x+cardW-bw, y:y+cardH+pad, w:bw, h:bh, label:'Next', on:()=>this.next()};
      this.btnSpeak  = {x:x+cardW/2-bw/2, y:y+cardH+pad, w:bw, h:bh, label:'Speak', on:()=>this.speak(), accent:true};
      this.btnShuffle= {x:x+cardW/2-bw/2, y:y - bh - pad, w:bw, h:bh, label:'Shuffle', on:()=>{}};
      this.btnHome   = {x:x+cardW - 104*DPR, y:y - bh - pad, w:100*DPR, h:bh, label:'Home', on:()=>go(Home)};
      [this.btnPrev,this.btnNext,this.btnSpeak,this.btnShuffle,this.btnHome].forEach(drawButton);
    }
  };

  // ---------- Quiz Scene ----------
  const Quiz = {
    id:'quiz',
    current:null, options:[], correctIndex:0, feedbackTimer:0,
    onEnter(){ setPlayed('quiz'); this.nextQuestion(); },
    nextQuestion(){
      const pool = shuffle([...WORDS]);
      this.current = pool[0];
      this.options = shuffle([pool[0].fr, pool[1].fr, pool[2].fr, pool[3].fr]);
      this.correctIndex = this.options.indexOf(this.current.fr);
      this.feedbackTimer=0;
    },
    choose(i){
      bump('quizTotal',1);
      if (i===this.correctIndex){ bump('quizCorrect',1); confettiBurst(); speakWord(this.current.fr, this.current.en); onWordHeard(this.current.fr); this.feedbackTimer=30; }
      else { speakOnce('Réessayez', 'fr-FR'); this.feedbackTimer=30; }
      setTimeout(()=>this.nextQuestion(), 450);
    },
    pointerDown(px,py){
      if (hit(this.btnHome,px,py)) return go(Home);
      for (let i=0;i<this.optRects.length;i++){ if (hit(this.optRects[i],px,py)) return this.choose(i); }
    },
    keyDown(k){
      if (k==='1') this.choose(0);
      if (k==='2') this.choose(1);
      if (k==='3') this.choose(2);
      if (k==='4') this.choose(3);
      if (k===' ') { if (this.current) speakWord(this.current.fr, this.current.en); onWordHeard(this.current.fr); }
      if (k==='Escape') go(Home);
    },
    draw(){
      drawBackground();
      const w=canvas.width,h=canvas.height;
      const cardW = Math.min(720*DPR, w*0.9), cardH = Math.min(500*DPR, h*0.75);
      const x = (w-cardW)/2, y = (h-cardH)/2;
      drawShadowBox(x,y,cardW,cardH, theme.cream, true);
      ctx.textAlign='center'; ctx.fillStyle = theme.bg;

      // Question
      ctx.font = font(Math.floor(26*DPR), 900);
      ctx.fillText(`Pick the French for: “${this.current.en}”`, x+cardW/2, y+40*DPR);

      // Options
      const gap=14*DPR, bw=cardW - 64*DPR, bh=64*DPR, left=x+32*DPR;
      this.optRects=[];
      for(let i=0;i<4;i++){
        const oy = y+110*DPR + i*(bh+gap);
        const rect = {x:left, y:oy, w:bw, h:bh};
        this.optRects.push(rect);
        const over = hit(rect, hoverX, hoverY);
        drawShadowBox(rect.x,rect.y,rect.w,rect.h, over? theme.coral : theme.gold, true);
        ctx.fillStyle = theme.bg;
        ctx.font = font(Math.floor(26*DPR), 800);
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(`${i+1}. ${this.options[i]}`, rect.x+rect.w/2, rect.y+rect.h/2+1);
      }

      // Bottom bar
      const t = ensureToday();
      this.btnHome = {x:x+cardW-120*DPR,y:y+cardH-64*DPR,w:110*DPR,h:52*DPR,label:'Home',accent:false};
      drawButton(this.btnHome);
      ctx.textAlign='left'; ctx.fillStyle='#334';
      ctx.font=font(Math.floor(16*DPR),700);
      ctx.fillText(`score today: ${t.quizCorrect}/${t.quizTotal}`, x+32*DPR, y+cardH-46*DPR);

      if (this.feedbackTimer>0){
        this.feedbackTimer--;
        ctx.globalAlpha = 0.9*(this.feedbackTimer/30);
        ctx.fillStyle = theme.teal;
        ctx.font = font(Math.floor(42*DPR),900);
        ctx.textAlign='center';
        ctx.fillText('✓', x+cardW/2, y+cardH-90*DPR);
        ctx.globalAlpha=1;
      }
    }
  };

  // ---------- Confetti ----------
  const confetti = [];
  function confettiBurst(cx=canvas.width/2, cy=canvas.height/2, n=22){
    for(let i=0;i<n;i++){
      confetti.push({x:cx,y:cy,vx:rnd(-2,2)*DPR,vy:rnd(-3,-0.5)*DPR, g:0.08*DPR, r:rnd(3,6)*DPR, life: 80+Math.random()*50, color: [theme.coral, theme.gold, theme.teal, theme.lilac][i%4]});
    }
  }
  function drawConfetti(){
    for(let i=confetti.length-1;i>=0;i--){
      const p=confetti[i]; p.x+=p.vx; p.y+=p.vy; p.vy+=p.g; p.life--;
      ctx.globalAlpha = clamp(p.life/100,0,1);
      ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
      if(p.life<=0) confetti.splice(i,1);
    }
    ctx.globalAlpha=1;
  }

  // ---------- Cheese Chase (Snake) ----------
  const CheeseChase = {
    id:'game',
    gridSize: 24, // cells
    cell: 20*DPR,
    speedMs: 140,
    timer:0,
    dir:{x:1,y:0}, nextDir:{x:1,y:0},
    mouse:[{x:5,y:12}], // body segments
    cheese:{x:10,y:12},
    growing:0,
    alive:true,
    lastWord:null,
    overlayTimer:0,
    onEnter(){
      setPlayed('game');
      this.init();
    },
    init(){
      const wCells = Math.floor((canvas.width*0.8)/(this.cell));
      const hCells = Math.floor((canvas.height*0.6)/(this.cell));
      this.cols = clamp(wCells, 14, 44);
      this.rows = clamp(hCells, 12, 30);
      this.speedMs = 140;
      this.mouse = [{x: (this.cols/2|0)-2, y: (this.rows/2|0) }];
      this.dir = {x:1,y:0}; this.nextDir={x:1,y:0};
      this.placeCheese();
      this.growing=0; this.alive=true; this.overlayTimer=0;
      this.lastWord = null;
      this.panel = this.layoutPanel();
    },
    layoutPanel(){
      const boardW = this.cols*this.cell, boardH=this.rows*this.cell;
      const x = (canvas.width-boardW)/2, y = (canvas.height-boardH)/2;
      return {x,y,w:boardW,h:boardH};
    },
    placeCheese(){
      let x,y,ok=false;
      while(!ok){
        x = (Math.random()*this.cols)|0; y=(Math.random()*this.rows)|0;
        ok = !this.mouse.some(s=>s.x===x&&s.y===y);
      }
      this.cheese={x,y};
    },
    eat(){
      // pick a word & speak
      const w = WORDS[(Math.random()*WORDS.length)|0];
      this.lastWord = w; this.overlayTimer = 80;
      speakWord(w.fr,w.en); onWordHeard(w.fr); bump('cheese',1);
      // grow and speed up a bit
      this.growing += 2;
      this.speedMs = clamp(this.speedMs - 3, 80, 200);
      this.placeCheese();
      confettiBurst(this.panel.x + this.cheese.x*this.cell + this.cell/2,
                    this.panel.y + this.cheese.y*this.cell + this.cell/2, 12);
    },
    step(){
      if (!this.alive) return;
      // update direction
      if ((this.nextDir.x !== -this.dir.x) || (this.nextDir.y !== -this.dir.y)) this.dir = {...this.nextDir};
      const head = {x:this.mouse[0].x + this.dir.x, y:this.mouse[0].y + this.dir.y};
      // wrap or collide?
      if (head.x<0 || head.x>=this.cols || head.y<0 || head.y>=this.rows) { return this.die(); }
      if (this.mouse.some(s=>s.x===head.x&&s.y===head.y)) { return this.die(); }
      this.mouse.unshift(head);
      if (head.x===this.cheese.x && head.y===this.cheese.y){
        this.eat(); // keeps extra segment(s)
      } else {
        if (this.growing>0) this.growing--; else this.mouse.pop();
      }
    },
    die(){
      this.alive=false;
      speakOnce('Oh non !', 'fr-FR');
      setTimeout(()=>this.init(), 900);
    },
    pointerDown(px,py){
      if (hit(this.btnHome,px,py)) return go(Home);
      // on-screen D-pad
      if (hit(this.padUp,px,py)) this.setDir(0,-1);
      if (hit(this.padDown,px,py)) this.setDir(0,1);
      if (hit(this.padLeft,px,py)) this.setDir(-1,0);
      if (hit(this.padRight,px,py)) this.setDir(1,0);
    },
    keyDown(k){
      if (k==='ArrowUp') this.setDir(0,-1);
      if (k==='ArrowDown') this.setDir(0,1);
      if (k==='ArrowLeft') this.setDir(-1,0);
      if (k==='ArrowRight') this.setDir(1,0);
      if (k===' ') { if (this.lastWord) speakWord(this.lastWord.fr, this.lastWord.en); }
      if (k==='Escape') go(Home);
    },
    setDir(x,y){
      // avoid instant reverse
      if (x===-this.dir.x && y===-this.dir.y) return;
      this.nextDir = {x,y};
    },
    update(dt){
      this.timer += dt;
      if (this.timer > this.speedMs){ this.timer=0; this.step(); }
      if (this.overlayTimer>0) this.overlayTimer--;
    },
    drawBoard(){
      const {x,y,w,h} = this.panel;
      drawShadowBox(x-10*DPR,y-10*DPR,w+20*DPR,h+20*DPR, theme.cream, true);
      // board tiles
      for(let r=0;r<this.rows;r++){
        for(let c=0;c<this.cols;c++){
          const even = ((r+c)&1)===0;
          ctx.fillStyle = even? '#2a355a' : '#233055';
          ctx.fillRect(x + c*this.cell, y + r*this.cell, this.cell, this.cell);
        }
      }
      // cheese
      const cx = x + this.cheese.x*this.cell + this.cell/2;
      const cy = y + this.cheese.y*this.cell + this.cell/2;
      ctx.save(); ctx.translate(cx,cy);
      ctx.fillStyle = theme.gold; ctx.strokeStyle = '#b38a00'; ctx.lineWidth=2*DPR;
      ctx.beginPath(); // triangle cheese wedge
      const s=this.cell*0.6;
      ctx.moveTo(-s/2, s/2); ctx.lineTo(s/2, s/2); ctx.lineTo(0,-s/2); ctx.closePath(); ctx.fill(); ctx.stroke();
      // holes
      ctx.fillStyle='rgba(0,0,0,0.15)';
      for(let i=0;i<3;i++){ ctx.beginPath(); ctx.arc(rnd(-s/4,s/4), rnd(-s/6,s/6), rnd(2*DPR,3.5*DPR), 0, Math.PI*2); ctx.fill(); }
      ctx.restore();

      // mouse (head with ears + body)
      ctx.fillStyle = theme.coral; ctx.strokeStyle='#913f39'; ctx.lineWidth=2*DPR;
      this.mouse.forEach((seg,i)=>{
        const mx = x + seg.x*this.cell + this.cell/2;
        const my = y + seg.y*this.cell + this.cell/2;
        if (i===0){
          // head
          ctx.beginPath(); ctx.arc(mx,my,this.cell*0.38,0,Math.PI*2); ctx.fill(); ctx.stroke();
          // ears
          ctx.beginPath(); ctx.arc(mx-6*DPR,my-8*DPR,4*DPR,0,Math.PI*2); ctx.arc(mx+6*DPR,my-8*DPR,4*DPR,0,Math.PI*2); ctx.fill();
          // eyes
          ctx.fillStyle='#1b213a';
          ctx.beginPath(); ctx.arc(mx-4*DPR,my-1*DPR,1.6*DPR,0,Math.PI*2); ctx.arc(mx+4*DPR,my-1*DPR,1.6*DPR,0,Math.PI*2); ctx.fill();
          // nose
          ctx.fillStyle=theme.lilac; ctx.beginPath(); ctx.arc(mx,my+4*DPR,1.6*DPR,0,Math.PI*2); ctx.fill();
        } else {
          ctx.fillStyle='#ff8b7f';
          ctx.beginPath(); ctx.arc(mx,my,this.cell*0.32,0,Math.PI*2); ctx.fill();
        }
      });

      // overlay word when eaten
      if (this.overlayTimer>0 && this.lastWord){
        const alpha = clamp(this.overlayTimer/80, 0, 1);
        ctx.globalAlpha = alpha;
        const bx = x + w/2 - 180*DPR, by = y - 70*DPR;
        drawShadowBox(bx,by,360*DPR,56*DPR, theme.teal, true);
        ctx.fillStyle = theme.bg;
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.font = font(Math.floor(22*DPR), 900);
        ctx.fillText(`${this.lastWord.fr}  —  ${this.lastWord.en}`, bx+180*DPR, by+28*DPR+1);
        ctx.globalAlpha=1;
      }
    },
    drawHUD(){
      const {x,y,w,h} = this.panel;
      // top bar
      ctx.textAlign='left'; ctx.textBaseline='top';
      ctx.fillStyle = theme.text;
      ctx.font = font(Math.floor(18*DPR),800);
      const t = ensureToday();
      ctx.fillText(`cheese: ${t.cheese}  •  words today: ${t.wordsHeard}`, x, y-44*DPR);

      // D-pad (for touch)
      const padS = 56*DPR, padGap=6*DPR, baseX = x+w+24*DPR, baseY = y+h- (padS*3 + padGap*2);
      this.padUp    = {x:baseX+padS, y:baseY, w:padS, h:padS, label:'▲'};
      this.padLeft  = {x:baseX, y:baseY+padS+padGap, w:padS, h:padS, label:'◀'};
      this.padRight = {x:baseX+padS*2+padGap*2 - padS, y:baseY+padS+padGap, w:padS, h:padS, label:'▶'};
      this.padDown  = {x:baseX+padS, y:baseY+(padS+padGap)*2, w:padS, h:padS, label:'▼'};
      [this.padUp,this.padLeft,this.padRight,this.padDown].forEach(b=>{
        drawShadowBox(b.x,b.y,b.w,b.h, hit(b,hoverX,hoverY)? theme.gold : theme.cream, true);
        ctx.fillStyle=theme.bg; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.font = font(Math.floor(26*DPR),900); ctx.fillText(b.label, b.x+b.w/2, b.y+b.h/2+1);
      });

      this.btnHome = {x:x+w-110*DPR,y:y-64*DPR,w:110*DPR,h:52*DPR,label:'Home'};
      drawButton(this.btnHome);
    },
    updateLayoutIfNeeded(){
      const newPanel = this.layoutPanel();
      if (!this.panel || Math.abs(newPanel.w-this.panel.w)>1 || Math.abs(newPanel.h-this.panel.h)>1){
        this.panel = newPanel;
      }
    },
    update(dt){ this.updateLayoutIfNeeded(); this.timer += dt; if (this.timer>this.speedMs){ this.timer=0; this.step(); } if (this.overlayTimer>0) this.overlayTimer--; },
    draw(){ drawBackground(); this.drawBoard(); this.drawHUD(); }
  };

  // ---------- Progress Scene ----------
  const Progress = {
    id:'progress',
    pointerDown(px,py){ if (hit(this.btnHome,px,py)) go(Home); if (hit(this.btnReset,px,py)) this.resetConfirm=true;
                         else if (this.resetConfirm && hit(this.btnYes,px,py)) { localStorage.removeItem(LS_KEY); progress=loadProgress(); this.resetConfirm=false; }
                         else if (this.resetConfirm && hit(this.btnNo,px,py)) this.resetConfirm=false; },
    keyDown(k){ if (k==='Escape') go(Home); },
    draw(){
      drawBackground();
      const w=canvas.width,h=canvas.height;
      const cardW = Math.min(840*DPR, w*0.92), cardH = Math.min(560*DPR, h*0.78);
      const x = (w-cardW)/2, y = (h-cardH)/2;
      drawShadowBox(x,y,cardW,cardH, theme.cream, true);

      ctx.textAlign='center'; ctx.fillStyle=theme.bg;
      ctx.font=font(Math.floor(30*DPR),900);
      ctx.fillText('Progress', x+cardW/2, y+28*DPR);

      const days = daysArray(14);
      const chart = {x:x+40*DPR, y:y+100*DPR, w:cardW-80*DPR, h:260*DPR};
      // axes
      ctx.strokeStyle='#2b3557'; ctx.lineWidth=2*DPR;
      ctx.beginPath(); ctx.moveTo(chart.x, chart.y); ctx.lineTo(chart.x, chart.y+chart.h); ctx.lineTo(chart.x+chart.w, chart.y+chart.h); ctx.stroke();
      // bars
      const bw = chart.w / days.length * 0.7;
      days.forEach((d,i)=>{
        const xp = xpForDay(d);
        const maxXP = 30; // clamp for scale
        const bh = clamp((xp/maxXP)*chart.h, 2, chart.h);
        const bx = chart.x + (i+0.15)*(chart.w/days.length);
        const by = chart.y + chart.h - bh;
        drawShadowBox(bx,by,bw,bh, theme.teal, false);
        // tick
        ctx.fillStyle='#556';
        ctx.font=font(Math.floor(12*DPR),700);
        const short = d.k.slice(5);
        ctx.textAlign='center'; ctx.fillText(short, bx+bw/2, chart.y+chart.h+16*DPR);
      });
      // metrics
      const streak = computeStreak();
      const t = ensureToday();
      ctx.textAlign='left'; ctx.fillStyle='#334'; ctx.font=font(Math.floor(18*DPR),800);
      ctx.fillText(`streak: ${streak} day${streak===1?'':'s'}`, x+40*DPR, y+chart.h+140*DPR);
      ctx.fillText(`today → words heard: ${t.wordsHeard}, cheese: ${t.cheese}, quiz: ${t.quizCorrect}/${t.quizTotal}, flashcards: ${t.flashcards}`, x+40*DPR, y+chart.h+170*DPR);

      // top words learned
      const top = Object.entries(progress.words).sort((a,b)=>b[1]-a[1]).slice(0,6);
      ctx.fillText(`top words: ${top.map(([w,c])=>`${w}×${c}`).join('  •  ') || '—'}`, x+40*DPR, y+chart.h+200*DPR);

      // buttons
      this.btnHome = {x:x+cardW-120*DPR,y:y+cardH-64*DPR,w:110*DPR,h:52*DPR,label:'Home'};
      this.btnReset= {x:x+40*DPR,y:y+cardH-64*DPR,w:140*DPR,h:52*DPR,label:'Reset Data'};
      drawButton(this.btnHome); drawButton(this.btnReset);

      if (this.resetConfirm){
        const mw=360*DPR,mh=160*DPR,mx=x+cardW/2-mw/2,my=y+cardH/2-mh/2;
        drawShadowBox(mx,my,mw,mh, theme.lilac,true);
        ctx.fillStyle=theme.bg; ctx.textAlign='center';
        ctx.font=font(Math.floor(18*DPR),900);
        ctx.fillText('erase all progress?', mx+mw/2, my+40*DPR);
        this.btnYes = {x:mx+40*DPR,y:my+mh-60*DPR,w:120*DPR,h:44*DPR,label:'Yes'};
        this.btnNo  = {x:mx+mw-160*DPR,y:my+mh-60*DPR,w:120*DPR,h:44*DPR,label:'No'};
        drawButton(this.btnYes); drawButton(this.btnNo);
      }
    }
  };

  // ---------- Global loop ----------
  let last = performance.now();
  function frame(now){
    const dt = now - last; last = now;
    // draw scenes
    if (currentScene && currentScene.update) currentScene.update(dt);
    drawBackground();
    if (currentScene && currentScene.draw) currentScene.draw();
    drawConfetti();
    requestAnimationFrame(frame);
  }

  // start
  go(Home);
  requestAnimationFrame(frame);

})();
</script>
</body>
</html>